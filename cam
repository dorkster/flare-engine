src/EventManager.cpp:732:	// When an event is delayed, we create a copy and push it to mapr->delayed_events.
src/EventManager.cpp:738:		mapr->delayed_events.push_back(ev);
src/EventManager.cpp:777:				mapr->teleportation = true;
src/EventManager.cpp:778:				mapr->teleport_mapname = ec->s;
src/EventManager.cpp:782:					mapr->teleport_destination.x = -1;
src/EventManager.cpp:783:					mapr->teleport_destination.y = -1;
src/EventManager.cpp:786:					mapr->teleport_destination.x = static_cast<float>(ec->x) + 0.5f;
src/EventManager.cpp:787:					mapr->teleport_destination.y = static_cast<float>(ec->y) + 0.5f;
src/EventManager.cpp:797:			mapr->teleportation = true;
src/EventManager.cpp:798:			mapr->teleport_mapname = "";
src/EventManager.cpp:799:			mapr->teleport_destination.x = static_cast<float>(ec->x) + 0.5f;
src/EventManager.cpp:800:			mapr->teleport_destination.y = static_cast<float>(ec->y) + 0.5f;
src/EventManager.cpp:804:				if (ec->x >= 0 && ec->x < mapr->w && ec->y >= 0 && ec->y < mapr->h) {
src/EventManager.cpp:805:					mapr->collider.colmap[ec->x][ec->y] = static_cast<unsigned short>(ec->z);
src/EventManager.cpp:806:					mapr->map_change = true;
src/EventManager.cpp:812:				size_t index = static_cast<size_t>(distance(mapr->layernames.begin(), find(mapr->layernames.begin(), mapr->layernames.end(), ec->s)));
src/EventManager.cpp:813:				if (!mapr->isValidTile(ec->z))
src/EventManager.cpp:815:				else if (index >= mapr->layers.size())
src/EventManager.cpp:817:				else if (ec->x >= 0 && ec->x < mapr->w && ec->y >= 0 && ec->y < mapr->h)
src/EventManager.cpp:818:					mapr->layers[index][ec->x][ec->y] = static_cast<unsigned short>(ec->z);
src/EventManager.cpp:844:			mapr->sids.push_back(sid);
src/EventManager.cpp:849:				mapr->loot_count.x = ec_lootcount->x;
src/EventManager.cpp:850:				mapr->loot_count.y = ec_lootcount->y;
src/EventManager.cpp:853:				mapr->loot_count.x = 0;
src/EventManager.cpp:854:				mapr->loot_count.y = 0;
src/EventManager.cpp:859:			mapr->loot.push_back(*ec);
src/EventManager.cpp:865:			mapr->cam.shake_timer.setDuration(ec->x);
src/EventManager.cpp:940:			mapr->activatePower(ec->id, ec->x, target);
src/EventManager.cpp:943:			mapr->stash = ec->x == 0 ? false : true;
src/EventManager.cpp:944:			if (mapr->stash) {
src/EventManager.cpp:945:				mapr->stash_pos.x = static_cast<float>(ev.location.x) + 0.5f;
src/EventManager.cpp:946:				mapr->stash_pos.y = static_cast<float>(ev.location.y) + 0.5f;
src/EventManager.cpp:950:			mapr->event_npc = ec->s;
src/EventManager.cpp:953:			mapr->music_filename = ec->s;
src/EventManager.cpp:954:			mapr->loadMusic();
src/EventManager.cpp:957:			mapr->cutscene = true;
src/EventManager.cpp:958:			mapr->cutscene_file = ec->s;
src/EventManager.cpp:964:			mapr->save_game = ec->x == 0 ? false : true;
src/EventManager.cpp:967:			mapr->npc_id = ec->x;
src/EventManager.cpp:970:			mapr->show_book = ec->s;
src/EventManager.cpp:1028:			mapr->setMapParallax(ec->s);
src/EventManager.cpp:1084:				ec_power->x = mapr->addEventStatBlock(script_evnt.front());
src/EventManager.cpp:1089:				mapr->delayed_events.push_back(script_evnt.front());
src/EventManager.cpp:1101:	if (fname == mapr->intermap_random_filename && !mapr->intermap_random_queue.empty()) {
src/EventManager.cpp:1102:		EventComponent ec = mapr->intermap_random_queue.front();
src/EventManager.cpp:1103:		mapr->intermap_random_queue.pop();
src/EventManager.cpp:1108:	while (!mapr->intermap_random_queue.empty()) {
src/EventManager.cpp:1109:		mapr->intermap_random_queue.pop();
src/EventManager.cpp:1122:				if (ec_list.empty() || ec.s != mapr->getFilename()) {
src/EventManager.cpp:1141:		mapr->intermap_random_filename = "";
src/EventManager.cpp:1145:		mapr->intermap_random_filename = fname;
src/EventManager.cpp:1149:			mapr->intermap_random_queue.push(ec_list[index]);
src/EventManager.cpp:1153:		EventComponent ec = mapr->intermap_random_queue.front();
src/EventManager.cpp:1154:		mapr->intermap_random_queue.pop();
src/LootManager.cpp:115:		mapr->collider.unblock(static_cast<float>(tiles_to_unblock[i].x), static_cast<float>(tiles_to_unblock[i].y));
src/LootManager.cpp:264:	if (!mapr->loot.empty()) {
src/LootManager.cpp:266:		if (mapr->loot_count.y != 0) {
src/LootManager.cpp:267:			drops = Math::randBetween(mapr->loot_count.x, mapr->loot_count.y);
src/LootManager.cpp:274:			checkLoot(mapr->loot, NULL, NULL);
src/LootManager.cpp:277:		mapr->loot.clear();
src/LootManager.cpp:278:		mapr->loot_count.x = 0;
src/LootManager.cpp:279:		mapr->loot_count.y = 0;
src/LootManager.cpp:677:	if (!mapr->collider.isValidPosition(p.x, p.y, MapCollision::MOVE_NORMAL, MapCollision::COLLIDE_NORMAL)) {
src/LootManager.cpp:678:		p = mapr->collider.getRandomNeighbor(src, eset->loot.drop_radius, !MapCollision::IGNORE_BLOCKED);
src/LootManager.cpp:680:		if (!mapr->collider.isValidPosition(p.x, p.y, MapCollision::MOVE_NORMAL, MapCollision::COLLIDE_NORMAL)) {
src/LootManager.cpp:687:			mapr->collider.block(p.x, p.y, !MapCollision::IS_ALLY);
src/NPCManager.cpp:75:	while (!mapr->npcs.empty()) {
src/NPCManager.cpp:76:		mn = mapr->npcs.front();
src/NPCManager.cpp:77:		mapr->npcs.pop();
src/NPCManager.cpp:110:	FPoint spawn_pos = mapr->collider.getRandomNeighbor(Point(pc->stats.pos), 1, !MapCollision::IGNORE_BLOCKED);
src/NPCManager.cpp:121:		mapr->collider.block(npc->stats.pos.x, npc->stats.pos.y, !MapCollision::IS_ALLY);
src/NPCManager.cpp:169:	mapr->events.push_back(ev);
src/GameStatePlay.cpp:139:	mapr->teleportation = true;
src/GameStatePlay.cpp:140:	mapr->teleport_mapname = "maps/spawn.txt";
src/GameStatePlay.cpp:179:			enemy = entitym->entityFocus(inpt->mouse, mapr->cam.pos, EntityManager::IS_ALIVE);
src/GameStatePlay.cpp:183:			src_pos = Utils::screenToMap(inpt->mouse.x, inpt->mouse.y, mapr->cam.pos.x, mapr->cam.pos.y);
src/GameStatePlay.cpp:197:		Entity *temp_enemy = entitym->entityFocus(inpt->mouse, mapr->cam.pos, !EntityManager::IS_ALIVE);
src/GameStatePlay.cpp:233:		focus_npc = npcs->npcFocus(inpt->mouse, mapr->cam.pos, true);
src/GameStatePlay.cpp:245:		Entity *temp_npc = npcs->npcFocus(inpt->mouse, mapr->cam.pos, false);
src/GameStatePlay.cpp:277:		pickup = loot->checkPickup(inpt->mouse, mapr->cam.pos, pc->stats.pos);
src/GameStatePlay.cpp:293:	if (mapr->teleportation || pc->stats.teleportation) {
src/GameStatePlay.cpp:295:		mapr->collider.unblock(pc->stats.pos.x, pc->stats.pos.y);
src/GameStatePlay.cpp:297:		if (mapr->teleportation) {
src/GameStatePlay.cpp:300:			pc->stats.pos.x = mapr->teleport_destination.x;
src/GameStatePlay.cpp:301:			pc->stats.pos.y = mapr->teleport_destination.y;
src/GameStatePlay.cpp:311:		if (mapr->teleport_mapname.empty()) {
src/GameStatePlay.cpp:312:			FPoint spawn_pos = mapr->collider.getRandomNeighbor(Point(pc->stats.pos), 1, !MapCollision::IGNORE_BLOCKED);
src/GameStatePlay.cpp:315:					mapr->collider.unblock(entitym->entities[i]->stats.pos.x, entitym->entities[i]->stats.pos.y);
src/GameStatePlay.cpp:317:					mapr->collider.block(entitym->entities[i]->stats.pos.x, entitym->entities[i]->stats.pos.y, MapCollision::IS_ALLY);
src/GameStatePlay.cpp:323:		if (mapr->teleportation && !mapr->teleport_mapname.empty()) {
src/GameStatePlay.cpp:324:			mapr->cam.warpTo(pc->stats.pos);
src/GameStatePlay.cpp:325:			std::string teleport_mapname = mapr->teleport_mapname;
src/GameStatePlay.cpp:326:			mapr->teleport_mapname = "";
src/GameStatePlay.cpp:328:			mapr->executeOnMapExitEvents();
src/GameStatePlay.cpp:330:			mapr->load(teleport_mapname);
src/GameStatePlay.cpp:334:			if (mapr->teleport_destination.x == -1 && mapr->teleport_destination.y == -1) {
src/GameStatePlay.cpp:335:				pc->stats.pos.x = mapr->hero_pos.x;
src/GameStatePlay.cpp:336:				pc->stats.pos.y = mapr->hero_pos.y;
src/GameStatePlay.cpp:337:				mapr->cam.warpTo(pc->stats.pos);
src/GameStatePlay.cpp:341:			if (mapr->collider.isValidPosition(pc->stats.pos.x, pc->stats.pos.y, MapCollision::MOVE_NORMAL, MapCollision::COLLIDE_HERO)) {
src/GameStatePlay.cpp:342:				mapr->respawn_map = teleport_mapname;
src/GameStatePlay.cpp:343:				mapr->respawn_point = pc->stats.pos;
src/GameStatePlay.cpp:352:			powers->handleNewMap(&mapr->collider);
src/GameStatePlay.cpp:357:			mapr->teleportation = false;
src/GameStatePlay.cpp:359:			mapr->executeOnLoadEvents();
src/GameStatePlay.cpp:360:			if (mapr->teleportation)
src/GameStatePlay.cpp:368:			menu->mini->prerender(&mapr->collider, mapr->w, mapr->h);
src/GameStatePlay.cpp:384:		if (mapr->collider.isOutsideMap(pc->stats.pos.x, pc->stats.pos.y)) {
src/GameStatePlay.cpp:390:		mapr->collider.block(pc->stats.pos.x, pc->stats.pos.y, !MapCollision::IS_ALLY);
src/GameStatePlay.cpp:395:	if (!on_load_teleport && mapr->teleport_mapname.empty())
src/GameStatePlay.cpp:396:		mapr->teleportation = false;
src/GameStatePlay.cpp:407:		mapr->respawn_point = pc->stats.pos;
src/GameStatePlay.cpp:469:	if (mapr->show_book != "") {
src/GameStatePlay.cpp:470:		menu->book->book_name = mapr->show_book;
src/GameStatePlay.cpp:471:		mapr->show_book = "";
src/GameStatePlay.cpp:707:	if (mapr->event_npc != "") {
src/GameStatePlay.cpp:712:		npc_id = mapr->npc_id = npcs->getID(mapr->event_npc);
src/GameStatePlay.cpp:715:	else if (mapr->npc_id != -1) {
src/GameStatePlay.cpp:716:		npc_id = mapr->npc_id;
src/GameStatePlay.cpp:719:	mapr->event_npc = "";
src/GameStatePlay.cpp:720:	mapr->npc_id = -1;
src/GameStatePlay.cpp:759:	if (mapr->stash) {
src/GameStatePlay.cpp:764:		mapr->stash = false;
src/GameStatePlay.cpp:775:		float interact_distance = Utils::calcDist(pc->stats.pos, mapr->stash_pos);
src/GameStatePlay.cpp:790:	if (!mapr->cutscene)
src/GameStatePlay.cpp:796:	if (!cutscene->load(mapr->cutscene_file)) {
src/GameStatePlay.cpp:798:		mapr->cutscene = false;
src/GameStatePlay.cpp:805:	if (mapr->teleportation) {
src/GameStatePlay.cpp:807:		if (mapr->teleport_mapname != "")
src/GameStatePlay.cpp:808:			mapr->respawn_map = mapr->teleport_mapname;
src/GameStatePlay.cpp:810:		mapr->respawn_point = mapr->teleport_destination;
src/GameStatePlay.cpp:814:		mapr->respawn_point = pc->stats.pos;
src/GameStatePlay.cpp:826:	if (mapr->save_game) {
src/GameStatePlay.cpp:827:		mapr->respawn_point = pc->stats.pos;
src/GameStatePlay.cpp:829:		mapr->save_game = false;
src/GameStatePlay.cpp:880:			mapr->checkHotspots();
src/GameStatePlay.cpp:881:			mapr->checkNearestEvent();
src/GameStatePlay.cpp:907:		comb->logic(mapr->cam.pos);
src/GameStatePlay.cpp:929:	mapr->logic(isPaused());
src/GameStatePlay.cpp:930:	mapr->enemies_cleared = entitym->isCleared();
src/GameStatePlay.cpp:1021:		mapr->loadMusic();
src/GameStatePlay.cpp:1031:	if (mapr->is_spawn_map)
src/GameStatePlay.cpp:1051:	mapr->render(rens, rens_dead);
src/GameStatePlay.cpp:1054:	loot->renderTooltips(mapr->cam.pos);
src/GameStatePlay.cpp:1056:	if (mapr->map_change) {
src/GameStatePlay.cpp:1057:		menu->mini->prerender(&mapr->collider, mapr->w, mapr->h);
src/GameStatePlay.cpp:1058:		mapr->map_change = false;
src/GameStatePlay.cpp:1060:	menu->mini->setMapTitle(mapr->title);
src/MenuExit.cpp:72:		mapr->respawn_point = pc->stats.pos;
src/NPC.cpp:344:	mapr->collider.unblock(stats.pos.x, stats.pos.y);
src/NPC.cpp:350:		mapr->collider.block(stats.pos.x, stats.pos.y, true);
src/NPC.cpp:509:	for (size_t i = 0; i < mapr->events.size(); i++)
src/NPC.cpp:511:		if (mapr->events[i].type == filename)
src/NPC.cpp:513:			mapr->events[i].location.x = static_cast<int>(stats.pos.x);
src/NPC.cpp:514:			mapr->events[i].location.y = static_cast<int>(stats.pos.y);
src/NPC.cpp:516:			mapr->events[i].hotspot.x = static_cast<int>(stats.pos.x);
src/NPC.cpp:517:			mapr->events[i].hotspot.y = static_cast<int>(stats.pos.y);
src/NPC.cpp:519:			mapr->events[i].center.x =
src/NPC.cpp:520:				static_cast<float>(stats.pos.x) + static_cast<float>(mapr->events[i].hotspot.w)/2;
src/NPC.cpp:521:			mapr->events[i].center.y =
src/NPC.cpp:522:				static_cast<float>(stats.pos.y) + static_cast<float>(mapr->events[i].hotspot.h)/2;
src/NPC.cpp:524:			for (size_t ci = 0; ci < mapr->events[i].components.size(); ci++)
src/NPC.cpp:526:				if (mapr->events[i].components[ci].type == EventComponent::NPC_HOTSPOT)
src/NPC.cpp:528:					mapr->events[i].components[ci].x = static_cast<int>(stats.pos.x);
src/NPC.cpp:529:					mapr->events[i].components[ci].y = static_cast<int>(stats.pos.y);
src/MenuActionBar.cpp:768:			map_pos = Utils::screenToMap(inpt->mouse.x,  inpt->mouse.y + eset->misc.aim_assist, mapr->cam.pos.x, mapr->cam.pos.y);
src/MenuActionBar.cpp:770:			map_pos = Utils::screenToMap(inpt->mouse.x,  inpt->mouse.y, mapr->cam.pos.x, mapr->cam.pos.y);
src/StatBlock.cpp:697:			mapr->collider.unblock(pos.x, pos.y);
src/StatBlock.cpp:962:		mapr->collider.unblock(pos.x, pos.y);
src/StatBlock.cpp:963:		mapr->collider.move(pos.x, pos.y, knockback_speed.x, knockback_speed.y, movement_type, mapr->collider.getCollideType(hero));
src/StatBlock.cpp:964:		mapr->collider.block(pos.x, pos.y, hero_ally);
src/StatBlock.cpp:971:		mapr->collider.unblock(pos.x, pos.y);
src/StatBlock.cpp:972:		mapr->collider.move(pos.x, pos.y, dx, dy, movement_type, mapr->collider.getCollideType(hero));
src/StatBlock.cpp:973:		mapr->collider.block(pos.x, pos.y, hero_ally);
src/Entity.cpp:212:	int collide_type = mapr->collider.getCollideType(stats.hero);
src/Entity.cpp:214:	while (!mapr->collider.isValidPosition(stats.pos.x, stats.pos.y, stats.movement_type, collide_type)) {
src/Entity.cpp:220:		if (mapr->collider.isValidPosition(stats.pos.x + 1, stats.pos.y, stats.movement_type, collide_type))
src/Entity.cpp:223:		if (mapr->collider.isValidPosition(stats.pos.x - 1, stats.pos.y, stats.movement_type, collide_type))
src/Entity.cpp:226:		if (mapr->collider.isValidPosition(stats.pos.x, stats.pos.y + 1, stats.movement_type, collide_type))
src/Entity.cpp:229:		if (mapr->collider.isValidPosition(stats.pos.x, stats.pos.y- 1, stats.movement_type, collide_type))
src/Entity.cpp:245:			while (radius <= std::max(mapr->w, mapr->h)) {
src/Entity.cpp:248:						if (mapr->collider.isValidPosition(static_cast<float>(i), static_cast<float>(j), stats.movement_type, collide_type)) {
src/Entity.cpp:299:	bool full_move = mapr->collider.move(stats.pos.x, stats.pos.y, dx, dy, stats.movement_type, mapr->collider.getCollideType(stats.hero));
src/Entity.cpp:343:	if (h.power->walls_block_aoe && !mapr->collider.lineOfMovement(stats.pos.x, stats.pos.y, h.pos.x, h.pos.y, MapCollision::MOVE_NORMAL))
src/Entity.cpp:513:			mapr->cam.shake_timer.setDuration(settings->max_frames_per_sec/2);
src/SaveLoad.cpp:132:		outfile << "spawn=" << mapr->respawn_map << "," << static_cast<int>(mapr->respawn_point.x) << "," << static_cast<int>(mapr->respawn_point.y) << "\n";
src/SaveLoad.cpp:319:				mapr->teleport_mapname = Parse::popFirstString(infile.val);
src/SaveLoad.cpp:320:				if (mapr->teleport_mapname != "" && Filesystem::fileExists(mods->locate(mapr->teleport_mapname))) {
src/SaveLoad.cpp:321:					mapr->teleport_destination.x = static_cast<float>(Parse::popFirstInt(infile.val)) + 0.5f;
src/SaveLoad.cpp:322:					mapr->teleport_destination.y = static_cast<float>(Parse::popFirstInt(infile.val)) + 0.5f;
src/SaveLoad.cpp:323:					mapr->teleportation = true;
src/SaveLoad.cpp:325:					mapr->clearEvents();
src/SaveLoad.cpp:328:					Utils::logError("SaveLoad: Unable to find %s, loading maps/spawn.txt", mapr->teleport_mapname.c_str());
src/SaveLoad.cpp:329:					mapr->teleport_mapname = "maps/spawn.txt";
src/SaveLoad.cpp:330:					mapr->teleport_destination.x = 0.5f;
src/SaveLoad.cpp:331:					mapr->teleport_destination.y = 0.5f;
src/SaveLoad.cpp:332:					mapr->teleportation = true;
src/Avatar.cpp:131:	if (mapr->hero_pos_enabled) {
src/Avatar.cpp:132:		stats.pos.x = mapr->hero_pos.x;
src/Avatar.cpp:133:		stats.pos.y = mapr->hero_pos.y;
src/Avatar.cpp:325:		FPoint target = Utils::screenToMap(inpt->mouse.x, inpt->mouse.y, mapr->cam.pos.x, mapr->cam.pos.y);
src/Avatar.cpp:367:	mapr->collider.unblock(stats.pos.x, stats.pos.y);
src/Avatar.cpp:458:	if (stats.transformed && mapr->collider.isValidPosition(stats.pos.x, stats.pos.y, MapCollision::MOVE_NORMAL, MapCollision::COLLIDE_HERO)) {
src/Avatar.cpp:460:		transform_map = mapr->getFilename();
src/Avatar.cpp:482:			else if (lock_enemy && powers->powers[mm_attack_id].requires_los && !mapr->collider.lineOfSight(stats.pos.x, stats.pos.y, lock_enemy->stats.pos.x, lock_enemy->stats.pos.y)) {
src/Avatar.cpp:489:	if (teleport_camera_lock && Utils::calcDist(stats.pos, mapr->cam.pos) < 0.5f) {
src/Avatar.cpp:585:				for (li = 0; li<mapr->layernames.size(); li++) {
src/Avatar.cpp:586:					if (mapr->layernames[li] == "fogofwar") {
src/Avatar.cpp:587:						Map_Layer fogLayer = mapr->layers[li];
src/Avatar.cpp:592:									Point hPoint = Utils::mapToScreen(stats.pos.x, stats.pos.y, mapr->cam.x, mapr->cam.y);
src/Avatar.cpp:595:										mapr->layers[li][lx][ly] = 0;
src/Avatar.cpp:629:					mapr->collider.block(stats.pos.x, stats.pos.y, !MapCollision::IS_ALLY);
src/Avatar.cpp:741:					mapr->teleportation = true;
src/Avatar.cpp:742:					mapr->teleport_mapname = mapr->respawn_map;
src/Avatar.cpp:746:						mapr->teleport_destination.x = stats.pos.x;
src/Avatar.cpp:747:						mapr->teleport_destination.y = stats.pos.y;
src/Avatar.cpp:753:						mapr->teleport_destination.x = mapr->respawn_point.x;
src/Avatar.cpp:754:						mapr->teleport_destination.y = mapr->respawn_point.y;
src/Avatar.cpp:784:					if (power.requires_los && !mapr->collider.lineOfSight(stats.pos.x, stats.pos.y, target.x, target.y))
src/Avatar.cpp:786:					if (power.requires_empty_target && !mapr->collider.isEmpty(target.x, target.y))
src/Avatar.cpp:858:	mapr->cam.setTarget(stats.pos);
src/Avatar.cpp:861:	mapr->checkEvents(stats.pos);
src/Avatar.cpp:871:	mapr->collider.block(stats.pos.x, stats.pos.y, !MapCollision::IS_ALLY);
src/Avatar.cpp:949:	transform_map = mapr->getFilename();
src/Avatar.cpp:957:	mapr->collider.unblock(stats.pos.x, stats.pos.y);
src/Avatar.cpp:958:	if (!mapr->collider.isValidPosition(stats.pos.x, stats.pos.y, MapCollision::MOVE_NORMAL, MapCollision::COLLIDE_HERO)) {
src/Avatar.cpp:960:		if (transform_map != mapr->getFilename()) {
src/Avatar.cpp:961:			mapr->teleportation = true;
src/Avatar.cpp:962:			mapr->teleport_mapname = transform_map;
src/Avatar.cpp:963:			mapr->teleport_destination.x = floorf(transform_pos.x) + 0.5f;
src/Avatar.cpp:964:			mapr->teleport_destination.y = floorf(transform_pos.y) + 0.5f;
src/Avatar.cpp:972:	mapr->collider.block(stats.pos.x, stats.pos.y, !MapCollision::IS_ALLY);
src/MenuMiniMap.cpp:579:	for (size_t i=0; i<mapr->events.size(); ++i) {
src/MenuMiniMap.cpp:580:		EventComponent* ec_minimap = mapr->events[i].getComponent(EventComponent::SHOW_ON_MINIMAP);
src/MenuMiniMap.cpp:584:		if (mapr->events[i].getComponent(EventComponent::NPC_HOTSPOT) && EventManager::isActive(mapr->events[i])) {
src/MenuMiniMap.cpp:585:			entities[mapr->events[i].location.x][mapr->events[i].location.y] = TILE_NPC;
src/MenuMiniMap.cpp:587:		else if ((mapr->events[i].activate_type == Event::ACTIVATE_ON_TRIGGER || mapr->events[i].activate_type == Event::ACTIVATE_ON_INTERACT) && mapr->events[i].getComponent(EventComponent::INTERMAP) && EventManager::isActive(mapr->events[i])) {
src/MenuMiniMap.cpp:589:			Point event_pos(mapr->events[i].location.x, mapr->events[i].location.y);
src/MenuMiniMap.cpp:590:			for (int j=event_pos.x; j<event_pos.x + mapr->events[i].location.w; ++j) {
src/MenuMiniMap.cpp:591:				for (int k=event_pos.y; k<event_pos.y + mapr->events[i].location.h; ++k) {
src/EntityBehavior.cpp:114:		mapr->collider.unblock(e->stats.pos.x,e->stats.pos.y);
src/EntityBehavior.cpp:119:		mapr->collider.block(e->stats.pos.x,e->stats.pos.y, e->stats.hero_ally);
src/EntityBehavior.cpp:151:		mapr->collider.unblock(e->stats.pos.x, e->stats.pos.y);
src/EntityBehavior.cpp:154:		mapr->collider.block(e->stats.pos.x, e->stats.pos.y, MapCollision::IS_ALLY);
src/EntityBehavior.cpp:182:		los = mapr->collider.lineOfSight(e->stats.pos.x, e->stats.pos.y, target_stats->pos.x, target_stats->pos.y);
src/EntityBehavior.cpp:260:				&& mapr->collider.isFacing(pc->stats.pos.x,pc->stats.pos.y,pc->stats.direction,e->stats.pos.x,e->stats.pos.y)) {
src/EntityBehavior.cpp:268:				&& mapr->collider.isFacing(pc->stats.pos.x,pc->stats.pos.y,pc->stats.direction,e->stats.pos.x,e->stats.pos.y)) {
src/EntityBehavior.cpp:301:			if (mapr->collider.isValidPosition(test_pos.x, test_pos.y, e->stats.movement_type, MapCollision::COLLIDE_NORMAL)) {
src/EntityBehavior.cpp:423:	mapr->collider.unblock(e->stats.pos.x, e->stats.pos.y);
src/EntityBehavior.cpp:433:			if (!mapr->collider.lineOfMovement(e->stats.pos.x, e->stats.pos.y, pursue_pos.x, pursue_pos.y, e->stats.movement_type)) {
src/EntityBehavior.cpp:479:					path_found = mapr->collider.computePath(e->stats.pos, pursue_pos, path, e->stats.movement_type, MapCollision::DEFAULT_PATH_LIMIT);
src/EntityBehavior.cpp:551:	mapr->collider.block(e->stats.pos.x, e->stats.pos.y, e->stats.hero_ally);
src/EntityBehavior.cpp:786:				mapr->collider.unblock(e->stats.pos.x, e->stats.pos.y);
src/EntityBehavior.cpp:789:				if (!mapr->collider.isValidPosition(e->stats.pos.x, e->stats.pos.y, MapCollision::MOVE_NORMAL, MapCollision::COLLIDE_NORMAL)) {
src/EntityBehavior.cpp:818:				mapr->collider.unblock(e->stats.pos.x, e->stats.pos.y);
src/EntityBehavior.cpp:842:	if (mapr->collider.isValidPosition(waypoint.x, waypoint.y, e->stats.movement_type, mapr->collider.getCollideType(e->stats.hero)) &&
src/EntityBehavior.cpp:843:	    mapr->collider.lineOfMovement(e->stats.pos.x, e->stats.pos.y, waypoint.x, waypoint.y, e->stats.movement_type))
src/MenuDevConsole.cpp:199:			target = Utils::screenToMap(inpt->mouse.x,  inpt->mouse.y, mapr->cam.pos.x, mapr->cam.pos.y);
src/MenuDevConsole.cpp:205:			if (!mapr->collider.isOutsideMap(floorf(target.x), floorf(target.y))) {
src/MenuDevConsole.cpp:252:	for (size_t i = 0; i < mapr->layers.size(); ++i) {
src/MenuDevConsole.cpp:253:		if (mapr->layers[i][tile.x][tile.y] == 0)
src/MenuDevConsole.cpp:256:		ss << "    " << mapr->layernames[i] << "=" << mapr->layers[i][tile.x][tile.y];
src/MenuDevConsole.cpp:261:	ss << "    " << "collision=" << mapr->collider.colmap[tile.x][tile.y] << " (";
src/MenuDevConsole.cpp:262:	switch(mapr->collider.colmap[tile.x][tile.y]) {
src/EntityManager.cpp:139:	while (!mapr->enemies.empty()) {
src/EntityManager.cpp:140:		me = mapr->enemies.front();
src/EntityManager.cpp:141:		mapr->enemies.pop();
src/EntityManager.cpp:177:		mapr->collider.block(me.pos.x, me.pos.y, !MapCollision::IS_ALLY);
src/EntityManager.cpp:180:	FPoint spawn_pos = mapr->collider.getRandomNeighbor(Point(pc->stats.pos), 1, !MapCollision::IGNORE_BLOCKED);
src/EntityManager.cpp:196:		mapr->collider.block(e->stats.pos.x, e->stats.pos.y, MapCollision::IS_ALLY);
src/EntityManager.cpp:226:	for (size_t i = 0; i < mapr->events.size(); i++) {
src/EntityManager.cpp:227:		for (size_t j = 0; j < mapr->events[i].components.size(); j++) {
src/EntityManager.cpp:228:			if (mapr->events[i].components[j].type == EventComponent::SPAWN) {
src/EntityManager.cpp:229:				std::vector<Enemy_Level> spawn_enemies = enemyg->getEnemiesInCategory(mapr->events[i].components[j].s);
src/EntityManager.cpp:252:		mapr->collider.unblock(espawn.pos.x, espawn.pos.y);
src/EntityManager.cpp:325:		if (mapr->collider.isValidPosition(espawn.pos.x, espawn.pos.y, e->stats.movement_type, MapCollision::COLLIDE_NORMAL) || !e->stats.hero_ally) {
src/EntityManager.cpp:364:		mapr->collider.block(e->stats.pos.x, e->stats.pos.y, e->stats.hero_ally);
src/EntityManager.cpp:471:	if (!mapr->collider.isEmpty(espawn.pos.x, espawn.pos.y)) {
src/EntityManager.cpp:475:		mapr->collider.block(espawn.pos.x, espawn.pos.y, !MapCollision::IS_ALLY);
